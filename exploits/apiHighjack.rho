// "API Highjacking for fun and profit"







new getMint, getPurse,
    print(`rho:io:stdout`)
in {
    @"MakeMint"!(*getMint)
    | for(@mint <- getMint) {
        @[mint, "makePurse"]!(100, *getPurseA)
        | @[mint, "makePurse"]!(100, *getPurseB)
        | for (@purseA <- getPurseA; @purseB <- getPurseB) {
            // ...
        }
    }
    
}






// Given a "Vault" structure, similar to the "coat check" example but for a pur$e

contract @"Vault"(return) = {
    new vault, storage in {
        contract @[*vault, "deposit"](@purse, return) = {
            new ticket in {
                @{*storage | *ticket}!(purse)
                | return!(*ticket)
            }
        }
        | contract @[*vault, "access"](ticket, return) = {
            new fetch in {
                for(@purse <! @{*storage, *ticket}) {
                    return!(purse)
                }
            }
        }
        return!(*vault)
    }
}


// make a public vault (any party can access)
| @"Vault"("makeVault")

// legitimate use of vault
| for (@vault <! @"makeVault") {   
    new getTicket in {
        @[*vault, "deposit"]!(@"a real purse", *getTicket)
        new getPurse in {
            @[*vault, ""]
            for (@purse <- )
        }
    }
}

// nefarious use of vault
| for (@vault <! @"makeVault") {
    // overwrite the "deposit" function of the vault.  This will work some portion of the time.
    for ([interceptedPurse, return] <- @[vault, "deposit"]) {
        
        // return fake ticket
        new fakeTicket in { return!(*fakeTicket) }

        // do something with purse
        | new getPurseBalance, drainPurse in {
            @[*interceptedPurse, "getBalance"]!(*getPurseBalance)
            | for (@balance <- getPurseBalance) {
                @[*interceptedPurse, "sprout"]!(balance, *drainPurse)
                | for (@illicitPurse <- drainPurse) {
                    // illicit purse obtained GOTO: buy drugs, or whatever
                }
            }
        }
    }

    | new internalReturn in {
        // intercept "fetch" 
        for (@[interceptedTicket, return] <- @[vault, "fetch"]) {
            match return == internalReturn with {
                true => { @[vault, "fetch"]!(interceptedTicket, return) } // caught yourself; try again
                false => {
                    new getPurse in {
                        @[vault, "fetch"]!(interceptedTicket, *getPurse)
                        for (@purse <- getPurse) {
                            // do something with purse
                        }
                    }
                }
            }
        }
    }
}


